package qln

import (
	"bytes"
	"fmt"
	"log"

	"github.com/adiabat/btcd/chaincfg/chainhash"
	"github.com/adiabat/btcd/wire"
	"github.com/btcsuite/fastsha256"
	"github.com/mit-dci/lit/lnutil"
	"github.com/mit-dci/lit/portxo"
)

/* CloseChannel --- cooperative close
This is the simplified close which sends to the same outputs as a break tx,
just with no timeouts.

Users might want a more advanced close function which allows multiple outputs.
They can exchange txouts and sigs.  That could be "fancyClose", but this is
just close, so only a signature is sent by the initiator, and the receiver
doesn't reply, as the channel is closed.

*/

// CoopClose requests a cooperative close of the channel
func (nd *LitNode) CoopClose(q *Qchan) error {

	nd.RemoteMtx.Lock()
	_, ok := nd.RemoteCons[q.Peer()]
	nd.RemoteMtx.Unlock()
	if !ok {
		return fmt.Errorf("not connected to peer %d ", q.Peer())
	}

	if q.CloseData.Closed {
		return fmt.Errorf("can't close (%d,%d): already closed",
			q.KeyGen.Step[3]&0x7fffffff, q.KeyGen.Step[4]&0x7fffffff)
	}

	tx, err := q.SimpleCloseTx()
	if err != nil {
		return err
	}

	sig, err := nd.SignSimpleClose(q, tx)
	if err != nil {
		return err
	}

	// Save something, just so the UI marks it as closed, and
	// we don't accept payments on this channel anymore.

	// save channel state as closed.  We know the txid... even though that
	// txid may not actually happen.
	q.CloseData.Closed = true
	q.CloseData.CloseTxid = tx.TxHash()
	err = nd.SaveQchanUtxoData(q)
	if err != nil {
		return err
	}

	var signature [64]byte
	copy(signature[:], sig[:])

	// Save something to db... TODO
	// Should save something, just so the UI marks it as closed, and
	// we don't accept payments on this channel anymore.

	outMsg := lnutil.NewCloseReqMsg(q.Peer(), q.Op, signature)

	nd.OmniOut <- outMsg
	return nil
}

// CloseReqHandler takes in a close request from a remote host, signs and
// responds with a close response.  Obviously later there will be some judgment
// over what to do, but for now it just signs whatever it's requested to.

func (nd *LitNode) CloseReqHandler(msg lnutil.CloseReqMsg) {
	opArr := lnutil.OutPointToBytes(msg.Outpoint)

	// find their sig
	theirSig := msg.Signature[:]

	// get channel
	q, err := nd.GetQchan(opArr)
	if err != nil {
		log.Printf("CloseReqHandler GetQchan err %s", err.Error())
		return
	}
	// verify their sig?  should do that before signing our side just to be safe

	// build close tx
	tx, err := q.SimpleCloseTx()
	if err != nil {
		log.Printf("CloseReqHandler SimpleCloseTx err %s", err.Error())
		return
	}

	// sign close
	mySig, err := nd.SignSimpleClose(q, tx)
	if err != nil {
		log.Printf("CloseReqHandler SignSimpleClose err %s", err.Error())
		return
	}
	pre, swap, err := lnutil.FundTxScript(q.MyPub, q.TheirPub)
	if err != nil {
		log.Printf("CloseReqHandler FundTxScript err %s", err.Error())
		return
	}

	// swap if needed
	if swap {
		tx.TxIn[0].Witness = SpendMultiSigWitStack(pre, theirSig, mySig)
	} else {
		tx.TxIn[0].Witness = SpendMultiSigWitStack(pre, mySig, theirSig)
	}
	log.Printf(lnutil.TxToString(tx))

	// save channel state to db as closed.
	q.CloseData.Closed = true
	q.CloseData.CloseTxid = tx.TxHash()
	err = nd.SaveQchanUtxoData(q)
	if err != nil {
		log.Printf("CloseReqHandler SaveQchanUtxoData err %s", err.Error())
		return
	}

	// broadcast
	err = nd.SubWallet.PushTx(tx)
	if err != nil {
		log.Printf("CloseReqHandler NewOutgoingTx err %s", err.Error())
		return
	}

	return
}

// GetCloseTxos takes in a tx and sets the QcloseTXO feilds based on the tx.
// It also returns the spendable (u)txos generated by the close.
// TODO way too long.  Need to split up.
// TODO problem with collisions, and insufficiently high elk receiver...?
func (q *Qchan) GetCloseTxos(tx *wire.MsgTx) ([]portxo.PorTxo, error) {
	if tx == nil {
		return nil, fmt.Errorf("IngesGetCloseTxostCloseTx: nil tx")
	}
	txid := tx.TxHash()
	// double check -- does this tx actually close the channel?
	if !(len(tx.TxIn) == 1 && lnutil.OutPointsEqual(tx.TxIn[0].PreviousOutPoint, q.Op)) {
		return nil, fmt.Errorf("tx %s doesn't spend channel outpoint %s",
			txid.String(), q.Op.String())
	}
	var shIdx, pkhIdx uint32
	var pkhIsMine bool
	cTxos := make([]portxo.PorTxo, 1)
	myPKHPkSript := lnutil.DirectWPKHScript(q.MyRefundPub)
	shIdx = 999 // set high here to detect if there's no SH output
	// Classify outputs.  Assumes only 1 SH output.  Later recognize HTLC outputs
	for i, out := range tx.TxOut {
		if len(out.PkScript) == 34 {
			shIdx = uint32(i)
		}
		if bytes.Equal(myPKHPkSript, out.PkScript) {
			pkhIdx = uint32(i)
			pkhIsMine = true
		}
	}

	// if pkh is mine, grab it.
	if pkhIsMine {
		fmt.Printf("got PKH output from channel close")
		var pkhTxo portxo.PorTxo // create new utxo and copy into it

		pkhTxo.Op.Hash = txid
		pkhTxo.Op.Index = pkhIdx
		pkhTxo.Height = q.CloseData.CloseHeight
		// keypath same, use different
		pkhTxo.KeyGen = q.KeyGen
		// same keygen as underlying channel, but use is refund
		pkhTxo.KeyGen.Step[2] = UseChannelRefund

		pkhTxo.Mode = portxo.TxoP2WPKHComp
		pkhTxo.Value = tx.TxOut[pkhIdx].Value
		// PKH, could omit this
		pkhTxo.PkScript = tx.TxOut[pkhIdx].PkScript
		cTxos[0] = pkhTxo
	}

	// get state hint based on pkh match.  If pkh is mine, that's their TX & hint.
	// if there's no PKH output for me, the TX is mine, so use my hint.
	var comNum uint64
	if pkhIsMine {
		comNum = GetStateIdxFromTx(tx, q.GetChanHint(false))
	} else {
		comNum = GetStateIdxFromTx(tx, q.GetChanHint(true))
	}
	if comNum > q.State.StateIdx { // future state, uhoh.  Crash for now.
		fmt.Printf("indicated state %d but we know up to %d",
			comNum, q.State.StateIdx)
		return cTxos, nil
	}

	// if we didn't get the pkh, and the comNum is current, we get the SH output.
	// also we probably closed ourselves.  Regular timeout
	if !pkhIsMine && shIdx < 999 && comNum != 0 && comNum == q.State.StateIdx {
		theirElkPoint, err := q.ElkPoint(false, comNum)
		if err != nil {
			return nil, err
		}

		// build script to store in porTxo, make pubkeys
		timeoutPub := lnutil.AddPubsEZ(q.MyHAKDBase, theirElkPoint)
		revokePub := lnutil.CombinePubs(q.TheirHAKDBase, theirElkPoint)

		script := lnutil.CommitScript(revokePub, timeoutPub, q.Delay)
		// script check.  redundant / just in case
		genSH := fastsha256.Sum256(script)
		if !bytes.Equal(genSH[:], tx.TxOut[shIdx].PkScript[2:34]) {
			fmt.Printf("got different observed and generated SH scripts.\n")
			fmt.Printf("in %s:%d, see %x\n", txid, shIdx, tx.TxOut[shIdx].PkScript)
			fmt.Printf("generated %x \n", genSH)
			fmt.Printf("revokable pub %x\ntimeout pub %x\n", revokePub, timeoutPub)
		}

		// create the ScriptHash, timeout portxo.
		var shTxo portxo.PorTxo // create new utxo and copy into it
		// use txidx's elkrem as it may not be most recent
		elk, err := q.ElkSnd.AtIndex(comNum)
		if err != nil {
			return nil, err
		}
		// keypath is the same, except for use
		shTxo.KeyGen = q.KeyGen

		shTxo.Op.Hash = txid
		shTxo.Op.Index = shIdx
		shTxo.Height = q.CloseData.CloseHeight

		shTxo.KeyGen.Step[2] = UseChannelHAKDBase

		elkpoint := lnutil.ElkPointFromHash(elk)
		addhash := chainhash.DoubleHashH(append(elkpoint[:], q.MyHAKDBase[:]...))

		shTxo.PrivKey = addhash

		shTxo.Mode = portxo.TxoP2WSHComp
		shTxo.Value = tx.TxOut[shIdx].Value
		shTxo.Seq = uint32(q.Delay)
		shTxo.PreSigStack = make([][]byte, 1) // revoke SH has one presig item
		shTxo.PreSigStack[0] = nil            // and that item is a nil (timeout)

		shTxo.PkScript = script
		cTxos[0] = shTxo
	}

	// if we got the pkh, and the comNum is too old, we can get the SH.  Justice.
	if pkhIsMine && comNum != 0 && comNum < q.State.StateIdx {
		// ---------- revoked SH is mine
		// invalid previous state, can be grabbed!
		// make MY elk points
		myElkPoint, err := q.ElkPoint(true, comNum)
		if err != nil {
			return nil, err
		}

		timeoutPub := lnutil.AddPubsEZ(q.TheirHAKDBase, myElkPoint)
		revokePub := lnutil.CombinePubs(q.MyHAKDBase, myElkPoint)
		script := lnutil.CommitScript(revokePub, timeoutPub, q.Delay)

		// script check
		wshScript := lnutil.P2WSHify(script)
		if !bytes.Equal(wshScript[:], tx.TxOut[shIdx].PkScript) {
			fmt.Printf("got different observed and generated SH scripts.\n")
			fmt.Printf("in %s:%d, see %x\n", txid, shIdx, tx.TxOut[shIdx].PkScript)
			fmt.Printf("generated %x \n", wshScript)
			fmt.Printf("revokable pub %x\ntimeout pub %x\n", revokePub, timeoutPub)
		}

		// myElkHashR added to HAKD private key
		elk, err := q.ElkRcv.AtIndex(comNum)
		if err != nil {
			return nil, err
		}

		var shTxo portxo.PorTxo // create new utxo and copy into it
		shTxo.KeyGen = q.KeyGen
		shTxo.Op.Hash = txid
		shTxo.Op.Index = shIdx
		shTxo.Height = q.CloseData.CloseHeight

		shTxo.KeyGen.Step[2] = UseChannelHAKDBase

		shTxo.PrivKey = lnutil.ElkScalar(elk)

		// just return the elkScalar and let
		// something modify it before export due to the seq=1 flag.

		shTxo.PkScript = script
		shTxo.Value = tx.TxOut[shIdx].Value
		shTxo.Mode = portxo.TxoP2WSHComp
		shTxo.Seq = 1                         // 1 means grab immediately
		shTxo.PreSigStack = make([][]byte, 1) // timeout SH has one presig item
		shTxo.PreSigStack[0] = []byte{0x01}   // and that item is a 1 (justice)
		cTxos = append(cTxos, shTxo)
	}

	return cTxos, nil
}
