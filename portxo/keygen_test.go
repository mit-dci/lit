package portxo

import (
	"bytes"
	"testing"
)

// Bytes(KeyGen method)
// no tests in case as follows
// because these cases are tested by built-in tests
//   KeyGen.Depth: nil, more than 2^8 - 1, less than 0
//   KeyGen.Step: nil, length more than 5,
//                element more than 2^32 - 1, element less than 0
func TestBytesForDepth1(t *testing.T) {
	// test for a normal situation
	// input: inKG, KeyGen
	//  Depth: 1
	//  Step: [5]uint32{0, 1, 2, 3, 4}
	//  PrivateKey: [32]byte{0x00, ..., 0x01}
	// want: wantB
	inKG := KeyGen{1,
		[5]uint32{0, 1, 2, 3, 4},
		[32]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}}
	wantB := []byte{0x01}
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x00}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x01}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x02}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x03}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x04}...)
	wantB = append(wantB, []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}...)

	if !bytes.Equal(inKG.Bytes(), wantB) {
		t.Fatalf("it needs to be equal")
	}
}

func TestBytesForDepth0(t *testing.T) {
	// test for an anomaly situation
	// input: inKG, KeyGen
	//  Depth: 0
	//  Step: [5]uint32{0, 1, 2, 3, 4}
	//  PrivateKey: [32]byte{0x00, ..., 0x01}
	// want: wantB
	inKG := KeyGen{0,
		[5]uint32{0, 1, 2, 3, 4},
		[32]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}}
	wantB := []byte{0x00}
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x00}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x01}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x02}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x03}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x04}...)
	wantB = append(wantB, []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}...)

	if !bytes.Equal(inKG.Bytes(), wantB) {
		t.Fatalf("it needs to be equal")
	}
}

func TestBytesForDepth6(t *testing.T) {
	// test for an anomaly situation
	// input: inKG, KeyGen
	//  Depth: 6
	//  Step: [5]uint32{0, 1, 2, 3, 4}
	//  PrivateKey: [32]byte{0x00, ..., 0x01}
	// want: wantB
	inKG := KeyGen{6,
		[5]uint32{0, 1, 2, 3, 4},
		[32]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}}

	wantB := []byte{0x06}
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x00}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x01}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x02}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x03}...)
	wantB = append(wantB, []byte{0x00, 0x00, 0x00, 0x04}...)
	wantB = append(wantB, []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}...)

	if !bytes.Equal(inKG.Bytes(), wantB) {
		t.Fatalf("it needs to be equal")
	}
}

// KeyGenFromBytes
func TestKeyGenFromBytesForDepth1(t *testing.T) {
	// test for a normal situation
	// input: inB
	// want: wantKG, KeyGen
	//  Depth: 1
	//  Step: [5]uint32{0, 1, 2, 3, 4}
	//  PrivateKey: [32]byte{0x00, ..., 0x01}
	inB := [53]byte{0x01,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x02,
		0x00, 0x00, 0x00, 0x03,
		0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}
	wantKG := KeyGen{1,
		[5]uint32{0, 1, 2, 3, 4},
		[32]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}}

	if KeyGenFromBytes(inB) != wantKG {
		t.Fatalf("it needs to be equal")
	}
}

func TestKeyGenFromBytesForDepth0(t *testing.T) {
	// test for an anomaly situation
	// input: inB
	// want: wantKG, KeyGen
	//  Depth: 0
	//  Step: [5]uint32{0, 1, 2, 3, 4}
	//  PrivateKey: [32]byte{0x00, ..., 0x01}
	inB := [53]byte{0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x02,
		0x00, 0x00, 0x00, 0x03,
		0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}
	wantKG := KeyGen{0,
		[5]uint32{0, 1, 2, 3, 4},
		[32]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}}

	if KeyGenFromBytes(inB) != wantKG {
		t.Fatalf("it needs to be equal")
	}
}

func TestKeyGenFromBytesForDepth6(t *testing.T) {
	// test for an anomaly situation
	// input: inB
	// want: wantKG, KeyGen
	//  Depth: 6
	//  Step: [5]uint32{0, 1, 2, 3, 4}
	//  PrivateKey: [32]byte{0x00, ..., 0x01}
	inB := [53]byte{0x06,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x02,
		0x00, 0x00, 0x00, 0x03,
		0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}
	wantKG := KeyGen{6,
		[5]uint32{0, 1, 2, 3, 4},
		[32]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}}

	if KeyGenFromBytes(inB) != wantKG {
		t.Fatalf("it needs to be equal")
	}
}

// String(KeyGen method)
func TestStringForDepth2(t *testing.T) {
	// test for a normal situation
	// input: inKG, KeyGen
	//  Depth: 2
	//  Step: [5]uint32{0, 1, 2, 3, 4}
	//  PrivateKey: [32]byte{0x00, ..., 0x01}
	// want: wantS, String
	inKG := KeyGen{2,
		[5]uint32{44, 0, 2, 3, 4},
		[32]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}}
	wantS := "/44/0"

	if inKG.String() != wantS {
		t.Fatalf("it needs to be equal")
	}
}

func TestStringForHardened(t *testing.T) {
	// test for a normal situation
	// input: inKG, KeyGen
	//  Depth: 3
	//  Step: [5]uint32{44, 0, 2147483648, 3, 4}
	//  PrivateKey: [32]byte{0x00, ..., 0x01}
	// want: wantS, String
	inKG := KeyGen{3,
		[5]uint32{44, 0, 2147483648, 3, 4},
		[32]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}}
	wantS := "/44/0/0'"

	if inKG.String() != wantS {
		t.Fatalf("it needs to be equal")
	}
}

func TestStringForDepth0(t *testing.T) {
	// test for an anomaly situation
	// input: inKG, KeyGen
	//  Depth: 0
	//  Step: [5]uint32{0, 1, 2, 3, 4}
	//  PrivateKey: [32]byte{0x00, ..., 0x01}
	// want: wantS, empty string
	inKG := KeyGen{0,
		[5]uint32{0, 1, 2, 3, 4},
		[32]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}}
	wantS := ""

	if inKG.String() != wantS {
		t.Fatalf("it needs to be equal")
	}
}

func TestStringForDepth6(t *testing.T) {
	// TODO: This case occurs panic because KeyGen.Depth is 6 but KeyGen.Step[5] is nothing
	//       It is better to add this test code after fixing the panic
	//
	// test for an anomaly situation
	// input: inKG, KeyGen
	//  Depth: 6
	//  Step: [5]uint32{0, 1, 2, 3, 4}
	//  PrivateKey: [32]byte{0x00, ..., 0x01}
	// want: wantS, String
	/*
		inKG := KeyGen{6,
			[5]uint32{0, 1, 2, 3, 4},
			[32]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}}
		wantS := "/0/1/2/3/4"

		if inKG.String() != wantS {
			t.Fatalf("it needs to be equal")
		}
	*/
}
